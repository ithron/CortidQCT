<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CortidQCT: CortidQCT::Mesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CortidQCT
   &#160;<span id="projectnumber">1.2.2.43</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCortidQCT.html">CortidQCT</a></li><li class="navelem"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCortidQCT_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CortidQCT::Mesh&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A triangle mesh class.  
 <a href="classCortidQCT_1_1Mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Mesh_8h_source.html">Mesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a81c02ff8c5040d90b417c8541e2e076b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81c02ff8c5040d90b417c8541e2e076b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a81c02ff8c5040d90b417c8541e2e076b">Scalar</a> = T</td></tr>
<tr class="memdesc:a81c02ff8c5040d90b417c8541e2e076b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type of the vector space the embedding. <br /></td></tr>
<tr class="separator:a81c02ff8c5040d90b417c8541e2e076b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ed47c4807bd85372175889555ed77c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85ed47c4807bd85372175889555ed77c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a85ed47c4807bd85372175889555ed77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index type. <br /></td></tr>
<tr class="separator:a85ed47c4807bd85372175889555ed77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2af31ab3131a4ce0a6ed86b6e29d8f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2af31ab3131a4ce0a6ed86b6e29d8f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ac2af31ab3131a4ce0a6ed86b6e29d8f9">Size</a> = std::size_t</td></tr>
<tr class="memdesc:ac2af31ab3131a4ce0a6ed86b6e29d8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structSize.html">Size</a> type. <br /></td></tr>
<tr class="separator:ac2af31ab3131a4ce0a6ed86b6e29d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29bc2956971579d646fc291c73a28a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29bc2956971579d646fc291c73a28a6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a> = unsigned int</td></tr>
<tr class="memdesc:ab29bc2956971579d646fc291c73a28a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label type. <br /></td></tr>
<tr class="separator:ab29bc2956971579d646fc291c73a28a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc0b8e9574d771ca005005cbcac05a67"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc0b8e9574d771ca005005cbcac05a67"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:adc0b8e9574d771ca005005cbcac05a67"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cartesianRepresentation</b> (<a class="el" href="structCortidQCT_1_1BarycentricPoint.html">BarycentricPoint</a>&lt; T, <a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a>&lt; T &gt;::<a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a> &gt; const &amp;point) const </td></tr>
<tr class="separator:adc0b8e9574d771ca005005cbcac05a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Construction</h2></td></tr>
<tr class="memitem:a6138fd5d8bef5ac2fcb65aba9f428071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6138fd5d8bef5ac2fcb65aba9f428071"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a6138fd5d8bef5ac2fcb65aba9f428071">Mesh</a> () noexcept(noexcept(VertexData())&amp;&amp;noexcept(IndexData())&amp;&amp;noexcept(LabelData())&amp;&amp;noexcept(VertexData()))</td></tr>
<tr class="memdesc:a6138fd5d8bef5ac2fcb65aba9f428071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty mesh. <br /></td></tr>
<tr class="separator:a6138fd5d8bef5ac2fcb65aba9f428071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2dc6ff80b1fcb5b49e30d75e5f7cb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb2dc6ff80b1fcb5b49e30d75e5f7cb6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#acb2dc6ff80b1fcb5b49e30d75e5f7cb6">Mesh</a> (std::size_t nVertices, std::size_t nTriangles) noexcept(noexcept(VertexData(3 *nVertices, T{0}))&amp;&amp;noexcept(IndexData(3 *nTriangles, <a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a>{0}))&amp;&amp;noexcept(LabelData(nVertices, <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a>{0}))&amp;&amp;noexcept(NormalData(3 *nVertices, T{0})))</td></tr>
<tr class="memdesc:acb2dc6ff80b1fcb5b49e30d75e5f7cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninitialized mesh with the given vertex and triangle count. <br /></td></tr>
<tr class="separator:acb2dc6ff80b1fcb5b49e30d75e5f7cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessors</h2></td></tr>
<tr class="memitem:a00230e71237643779b241188e7acd84d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00230e71237643779b241188e7acd84d"></a>
<a class="el" href="classCortidQCT_1_1Mesh.html#ac2af31ab3131a4ce0a6ed86b6e29d8f9">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a00230e71237643779b241188e7acd84d">vertexCount</a> () const noexcept</td></tr>
<tr class="memdesc:a00230e71237643779b241188e7acd84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vertices. <br /></td></tr>
<tr class="separator:a00230e71237643779b241188e7acd84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa13bb1e91743e14be3869f29a6b6d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aa13bb1e91743e14be3869f29a6b6d3"></a>
<a class="el" href="classCortidQCT_1_1Mesh.html#ac2af31ab3131a4ce0a6ed86b6e29d8f9">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a0aa13bb1e91743e14be3869f29a6b6d3">triangleCount</a> () const noexcept</td></tr>
<tr class="memdesc:a0aa13bb1e91743e14be3869f29a6b6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of triangles. <br /></td></tr>
<tr class="separator:a0aa13bb1e91743e14be3869f29a6b6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1637fc84ae7be14d674208085ef34b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#abb1637fc84ae7be14d674208085ef34b">isEmpty</a> () const noexcept</td></tr>
<tr class="memdesc:abb1637fc84ae7be14d674208085ef34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff the mesh is empty  <a href="#abb1637fc84ae7be14d674208085ef34b">More...</a><br /></td></tr>
<tr class="separator:abb1637fc84ae7be14d674208085ef34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
IO</h2></td></tr>
<tr class="memitem:af30f2e1fad4041986c2b3d680112ffab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#af30f2e1fad4041986c2b3d680112ffab">loadFromFile</a> (std::string const &amp;meshFilename, std::string const &amp;labelFilename)</td></tr>
<tr class="memdesc:af30f2e1fad4041986c2b3d680112ffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load mesh and labels from ASCII file using format auto detection.  <a href="#af30f2e1fad4041986c2b3d680112ffab">More...</a><br /></td></tr>
<tr class="separator:af30f2e1fad4041986c2b3d680112ffab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93859cb1f166e04d9695c8e621b1ed25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a93859cb1f166e04d9695c8e621b1ed25">loadFromFile</a> (std::string const &amp;meshFilename, <a class="el" href="namespaceCortidQCT.html#acad86b84ee91fd3a7256aabef3612459">ColorToLabelMap</a>&lt; <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a>, double &gt; const &amp;colorMap=<a class="el" href="namespaceCortidQCT_1_1ColorToLabelMaps.html#aa72229d455b99ac37f635715b23b0f1e">ColorToLabelMaps::defaultMap</a>&lt; <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a>, double &gt;)</td></tr>
<tr class="memdesc:a93859cb1f166e04d9695c8e621b1ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load mesh from ASCII file using format auto detection and extract labels from per-vertex colors.  <a href="#a93859cb1f166e04d9695c8e621b1ed25">More...</a><br /></td></tr>
<tr class="separator:a93859cb1f166e04d9695c8e621b1ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19e59dc75cd1c4453e941e33b6681bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ac19e59dc75cd1c4453e941e33b6681bd">writeToFile</a> (std::string const &amp;meshFilename, std::string const &amp;labelFilename) const </td></tr>
<tr class="memdesc:ac19e59dc75cd1c4453e941e33b6681bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes mesh to ASCII file using format auto detection.  <a href="#ac19e59dc75cd1c4453e941e33b6681bd">More...</a><br /></td></tr>
<tr class="separator:ac19e59dc75cd1c4453e941e33b6681bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52ab27d64c744316abc0f565de1abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#aea52ab27d64c744316abc0f565de1abc">writeToFile</a> (std::string const &amp;meshFilename, <a class="el" href="namespaceCortidQCT.html#a04ddf5259cabc1e1238ae30285564dfc">LabelToColorMap</a>&lt; double, <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a> &gt; const &amp;labelMap=<a class="el" href="namespaceCortidQCT_1_1LabelToColorMaps.html#a2fa866efe763cce246044753efbce53b">LabelToColorMaps::defaultMap</a>&lt; double, <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a> &gt;) const </td></tr>
<tr class="memdesc:aea52ab27d64c744316abc0f565de1abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes mesh to ASCII file using format auto detection and encode labels as colors.  <a href="#aea52ab27d64c744316abc0f565de1abc">More...</a><br /></td></tr>
<tr class="separator:aea52ab27d64c744316abc0f565de1abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Queries</h2></td></tr>
<tr class="memitem:a72cbf64c5fdcfec7b414df1dc7e57d55"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a72cbf64c5fdcfec7b414df1dc7e57d55">cartesianRepresentation</a> (<a class="el" href="structCortidQCT_1_1BarycentricPoint.html">BarycentricPoint</a>&lt; T, <a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a> &gt; const &amp;point) const </td></tr>
<tr class="memdesc:a72cbf64c5fdcfec7b414df1dc7e57d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cartesian coordinate of a point in barycentric coordinates.  <a href="#a72cbf64c5fdcfec7b414df1dc7e57d55">More...</a><br /></td></tr>
<tr class="separator:a72cbf64c5fdcfec7b414df1dc7e57d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddaf19240c4ce4efe34adefe6c8b8c8"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a0ddaf19240c4ce4efe34adefe6c8b8c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a0ddaf19240c4ce4efe34adefe6c8b8c8">cartesianRepresentation</a> (InputIterator begin, InputIterator end, OutputIterator out) const </td></tr>
<tr class="memdesc:a0ddaf19240c4ce4efe34adefe6c8b8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a sequence of barycentric coordinates into caresian coordinates.  <a href="#a0ddaf19240c4ce4efe34adefe6c8b8c8">More...</a><br /></td></tr>
<tr class="separator:a0ddaf19240c4ce4efe34adefe6c8b8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f056311a26858c6c1355821e810e9dc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; T, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a8f056311a26858c6c1355821e810e9dc">cartesianRepresentation</a> (std::vector&lt; <a class="el" href="structCortidQCT_1_1BarycentricPoint.html">BarycentricPoint</a>&lt; T, <a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a> &gt;&gt; const &amp;points) const </td></tr>
<tr class="memdesc:a8f056311a26858c6c1355821e810e9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a sequence of barycentric coordinates into caresian coordinates.  <a href="#a8f056311a26858c6c1355821e810e9dc">More...</a><br /></td></tr>
<tr class="separator:a8f056311a26858c6c1355821e810e9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d08d1f06372f31e187d626d273044f5"><td class="memTemplParams" colspan="2">template&lt;class PtIter , class AttrIter , class OutputIterator &gt; </td></tr>
<tr class="memitem:a2d08d1f06372f31e187d626d273044f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a2d08d1f06372f31e187d626d273044f5">barycentricInterpolation</a> (PtIter pointsBegin, PtIter pointsEnd, AttrIter attributesBegin, OutputIterator out, std::size_t attributeDimension=1) const </td></tr>
<tr class="memdesc:a2d08d1f06372f31e187d626d273044f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates per-vertex values for points inside a triangle.  <a href="#a2d08d1f06372f31e187d626d273044f5">More...</a><br /></td></tr>
<tr class="separator:a2d08d1f06372f31e187d626d273044f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5055fa34780c0c454e8456416e10f7c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:aa5055fa34780c0c454e8456416e10f7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#aa5055fa34780c0c454e8456416e10f7c">rayIntersections</a> (InputIterator raysBegin, InputIterator raysEnd, OutputIterator intersectionsOut) const </td></tr>
<tr class="memdesc:aa5055fa34780c0c454e8456416e10f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of a set of rays with the mesh.  <a href="#aa5055fa34780c0c454e8456416e10f7c">More...</a><br /></td></tr>
<tr class="separator:aa5055fa34780c0c454e8456416e10f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae398361b2609e87158aa2131136c744b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCortidQCT_1_1RayMeshIntersection.html">RayMeshIntersection</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ae398361b2609e87158aa2131136c744b">rayIntersection</a> (<a class="el" href="structCortidQCT_1_1Ray.html">Ray</a>&lt; T &gt; const &amp;ray) const </td></tr>
<tr class="memdesc:ae398361b2609e87158aa2131136c744b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes intersection with the given ray and the mesh.  <a href="#ae398361b2609e87158aa2131136c744b">More...</a><br /></td></tr>
<tr class="separator:ae398361b2609e87158aa2131136c744b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ac2e60cdfe1606794be86f375e5793"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6ac2e60cdfe1606794be86f375e5793"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ae6ac2e60cdfe1606794be86f375e5793">updatePerVertexNormals</a> ()</td></tr>
<tr class="memdesc:ae6ac2e60cdfe1606794be86f375e5793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-computes per-vertex normals. <br /></td></tr>
<tr class="separator:ae6ac2e60cdfe1606794be86f375e5793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Modifyers</h2></td></tr>
<tr class="memitem:a8c11db0cf6dbafef494b8fce1307b0cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a8c11db0cf6dbafef494b8fce1307b0cd">upsample</a> (std::size_t nTimes=1)</td></tr>
<tr class="memdesc:a8c11db0cf6dbafef494b8fce1307b0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upsample the mesh without touching the original vertices.  <a href="#a8c11db0cf6dbafef494b8fce1307b0cd">More...</a><br /></td></tr>
<tr class="separator:a8c11db0cf6dbafef494b8fce1307b0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Raw Data Access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5ca44632aa0249cff3ff2b20736df42c"></a>The methods in this section all call a functional with a pointer to raw data as its argument. The pointer only guaranteed to be valid within the call to the given functional.</p>
<dl class="section attention"><dt>Attention</dt><dd>Do not return the raw data pointer or save it in any other way! </dd></dl>
</td></tr>
<tr class="memitem:a1f08cb96ee61f455b4f4d317764a5235"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a1f08cb96ee61f455b4f4d317764a5235"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a1f08cb96ee61f455b4f4d317764a5235">withUnsafeVertexPointer</a> (F &amp;&amp;f) const noexcept(noexcept(f(std::declval&lt; const VertexData &gt;().data())))</td></tr>
<tr class="memdesc:a1f08cb96ee61f455b4f4d317764a5235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given functional with an unsafe pointer to the raw vertex storage.  <a href="#a1f08cb96ee61f455b4f4d317764a5235">More...</a><br /></td></tr>
<tr class="separator:a1f08cb96ee61f455b4f4d317764a5235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb087fc25df8e695a7fcdbd268ceb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39eb087fc25df8e695a7fcdbd268ceb7"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a39eb087fc25df8e695a7fcdbd268ceb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>withUnsafeVertexPointer</b> (F &amp;&amp;f) noexcept(noexcept(f(std::declval&lt; VertexData &gt;().data())))</td></tr>
<tr class="separator:a39eb087fc25df8e695a7fcdbd268ceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6334c55d0c95f19bc6214983ba4dc29"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ac6334c55d0c95f19bc6214983ba4dc29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ac6334c55d0c95f19bc6214983ba4dc29">withUnsafeIndexPointer</a> (F &amp;&amp;f) const noexcept(noexcept(f(std::declval&lt; const IndexData &gt;().data())))</td></tr>
<tr class="memdesc:ac6334c55d0c95f19bc6214983ba4dc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given functional with an unsafe pointer to the raw index storage.  <a href="#ac6334c55d0c95f19bc6214983ba4dc29">More...</a><br /></td></tr>
<tr class="separator:ac6334c55d0c95f19bc6214983ba4dc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151ead43dfb82ba7fc56ea51b560abfa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a151ead43dfb82ba7fc56ea51b560abfa"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a151ead43dfb82ba7fc56ea51b560abfa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>withUnsafeIndexPointer</b> (F &amp;&amp;f) noexcept(noexcept(f(std::declval&lt; IndexData &gt;().data())))</td></tr>
<tr class="separator:a151ead43dfb82ba7fc56ea51b560abfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8173d354feb4ca374319272687f1f427"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a8173d354feb4ca374319272687f1f427"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#a8173d354feb4ca374319272687f1f427">withUnsafeLabelPointer</a> (F &amp;&amp;f) const noexcept(noexcept(f(LabelData().data())))</td></tr>
<tr class="memdesc:a8173d354feb4ca374319272687f1f427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given functional with an unsafe pointer to the raw label storage.  <a href="#a8173d354feb4ca374319272687f1f427">More...</a><br /></td></tr>
<tr class="separator:a8173d354feb4ca374319272687f1f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b21a9d409d54cdeb48bb5e605b48775"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b21a9d409d54cdeb48bb5e605b48775"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a8b21a9d409d54cdeb48bb5e605b48775"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>withUnsafeLabelPointer</b> (F &amp;&amp;f) noexcept(noexcept(f(LabelData().data())))</td></tr>
<tr class="separator:a8b21a9d409d54cdeb48bb5e605b48775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52c7c438cecf75588ca5abb81793288"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ad52c7c438cecf75588ca5abb81793288"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCortidQCT_1_1Mesh.html#ad52c7c438cecf75588ca5abb81793288">withUnsafeVertexNormalPointer</a> (F &amp;&amp;f) const noexcept(noexcept(f(std::declval&lt; const NormalData &gt;().data())))</td></tr>
<tr class="memdesc:ad52c7c438cecf75588ca5abb81793288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given functional with an unsafe pointer to the raw per vertex normal storage.  <a href="#ad52c7c438cecf75588ca5abb81793288">More...</a><br /></td></tr>
<tr class="separator:ad52c7c438cecf75588ca5abb81793288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ed4d4fd9ff81ef7f79634f28cdc985"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60ed4d4fd9ff81ef7f79634f28cdc985"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a60ed4d4fd9ff81ef7f79634f28cdc985"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>withUnsafeVertexNormalPointer</b> (F &amp;&amp;f) noexcept(noexcept(f(std::declval&lt; NormalData &gt;().data())))</td></tr>
<tr class="separator:a60ed4d4fd9ff81ef7f79634f28cdc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class CortidQCT::Mesh&lt; T &gt;</h3>

<p>A triangle mesh class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the vector space of the embedding, must be a floating point type</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2d08d1f06372f31e187d626d273044f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class PtIter , class AttrIter , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::barycentricInterpolation </td>
          <td>(</td>
          <td class="paramtype">PtIter&#160;</td>
          <td class="paramname"><em>pointsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtIter&#160;</td>
          <td class="paramname"><em>pointsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AttrIter&#160;</td>
          <td class="paramname"><em>attributesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>attributeDimension</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates per-vertex values for points inside a triangle. </p>
<p>This input of this function are some points on the surfac of the mesh in barycentric representation and a vector of per-vertex attributes/values that are to be interpolated. The per-vertex attributes/values do not have to be scalar, vector values attributes can be used by setting the <code>attributeDimension</code> paremter. The attributes must be in row major order, i.e. a full attribute vector is stored in consecutively in the underlying container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PtIter</td><td>InputIterator of <a class="el" href="structCortidQCT_1_1BarycentricPoint.html" title="BarycentricPoint data type. Represents a points on triangulation in barycentric coordinates. ">BarycentricPoint</a> type </td></tr>
    <tr><td class="paramname">AttrIter</td><td>RandomAccessIterator of scalar type </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>output iterator acceptiong scalar of the same type as AttrIter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointsBegin</td><td>input iterator pointing to the first barycentric point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointsEnd</td><td>input iterator pointing one element past the last barycentric point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributesBegin</td><td>random access iterator pointing to the first attribute vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributeDimension</td><td>number of attribute dimensions, defaults to 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if a trinagle index is out of range In case of an exception <code>out</code> is only untouched if and only if <code>PtIter</code> conforms to <code>ForwardIterator</code>. If <code>PtIter</code> only conforms to <code>IputIterator</code>, all values up to the one where the exception happened will be written to <code>out</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72cbf64c5fdcfec7b414df1dc7e57d55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, 3&gt; <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::cartesianRepresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCortidQCT_1_1BarycentricPoint.html">BarycentricPoint</a>&lt; T, <a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cartesian coordinate of a point in barycentric coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>point in barycentric coodinate representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vartesian coordinates of the point </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the triangle index of the point is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ddaf19240c4ce4efe34adefe6c8b8c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::cartesianRepresentation </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a sequence of barycentric coordinates into caresian coordinates. </p>
<p>The implementation uses barycetnricInterpolation. OutputIterator's value_type must be T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>iterator that points to the first cartesian point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>interator that points right after the last point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if a triangle index is out of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCortidQCT_1_1Mesh.html#a2d08d1f06372f31e187d626d273044f5" title="Interpolates per-vertex values for points inside a triangle. ">barycentricInterpolation</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f056311a26858c6c1355821e810e9dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::array&lt;T, 3&gt; &gt; <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::cartesianRepresentation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCortidQCT_1_1BarycentricPoint.html">BarycentricPoint</a>&lt; T, <a class="el" href="classCortidQCT_1_1Mesh.html#a85ed47c4807bd85372175889555ed77c">Index</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a sequence of barycentric coordinates into caresian coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>std::vector of barycentric points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of cartesian points </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if a triangle index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb1637fc84ae7be14d674208085ef34b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true iff the mesh is empty </p>
<p>The mesh is empty iff the triangle or the vertex count is zero </p>

</div>
</div>
<a class="anchor" id="af30f2e1fad4041986c2b3d680112ffab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp; <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>meshFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>labelFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load mesh and labels from ASCII file using format auto detection. </p>
<p>Supported file formats are: obj, off, stl, wrl, ply, mesh, SIMesh. If a .off file with color data (COFF) is given and the labels should be extracted from the color data, use the overload <code>loadFromFile(std::string const &amp;, ColorToLabelMap&lt;Label, double&gt; const &amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshFilename</td><td>Path to the file to load the mesh from </td></tr>
    <tr><td class="paramname">labelFilename</td><td>Optional path to the file to load the vertex labels from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the loaded mesh </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the mesh or the labels could not be loaded from the given filename </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the file file format could not be recognized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93859cb1f166e04d9695c8e621b1ed25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp; <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>meshFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceCortidQCT.html#acad86b84ee91fd3a7256aabef3612459">ColorToLabelMap</a>&lt; <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a>, double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>colorMap</em> = <code><a class="el" href="namespaceCortidQCT_1_1ColorToLabelMaps.html#aa72229d455b99ac37f635715b23b0f1e">ColorToLabelMaps::defaultMap</a>&lt;<a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a>,&#160;double&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load mesh from ASCII file using format auto detection and extract labels from per-vertex colors. </p>
<p>Supported file formats are: off (COFF), SIMesh. Per-vertex colors are converted to labels using the given colormap. For SIMesh format, the labels are directly read from the file. For other formats use the overload <code><a class="el" href="classCortidQCT_1_1Mesh.html#af30f2e1fad4041986c2b3d680112ffab" title="Load mesh and labels from ASCII file using format auto detection. ">loadFromFile(std::string const &amp;, std::string const &amp;)</a></code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshFilename</td><td>Path to the file to load the mesh from </td></tr>
    <tr><td class="paramname">colorMap</td><td>Mapping from RGB colorspace to labels. Defaults to <code><a class="el" href="namespaceCortidQCT_1_1ColorToLabelMaps.html#aa72229d455b99ac37f635715b23b0f1e" title="Default color to label map. ">ColorToLabelMaps::defaultMap()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the loaded mesh </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the mesh could not be loaded from the given filename </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the file file format could not be recognized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae398361b2609e87158aa2131136c744b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCortidQCT_1_1RayMeshIntersection.html">RayMeshIntersection</a>&lt; T &gt; <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::rayIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCortidQCT_1_1Ray.html">Ray</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ray</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes intersection with the given ray and the mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCortidQCT_1_1Mesh.html#aa5055fa34780c0c454e8456416e10f7c" title="Computes the intersection of a set of rays with the mesh. ">rayIntersections</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Query ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCortidQCT_1_1RayMeshIntersection.html">RayMeshIntersection</a> object describing the intersection. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5055fa34780c0c454e8456416e10f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::rayIntersections </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>raysBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>raysEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>intersectionsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of a set of rays with the mesh. </p>
<p>If for any ray no intersection can be found, the corresponding <a class="el" href="structCortidQCT_1_1RayMeshIntersection.html">RayMeshIntersection</a> object is left with its default values (its signed distance is infinity).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Input iterator with value_type of <a class="el" href="structCortidQCT_1_1Ray.html" title="A basic ray datatype. ">Ray</a> </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Output iterator with value_type of <a class="el" href="structCortidQCT_1_1RayMeshIntersection.html">RayMeshIntersection</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raysBegin</td><td>Iterator poiting to the first ray </td></tr>
    <tr><td class="paramname">raysEnd</td><td>Iterator pointing one element past the last ray </td></tr>
    <tr><td class="paramname">intersectionsOut</td><td>Output iterator for intersections </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c11db0cf6dbafef494b8fce1307b0cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCortidQCT_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp; <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::upsample </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nTimes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upsample the mesh without touching the original vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTimes</td><td>number of subsample iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6334c55d0c95f19bc6214983ba4dc29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::withUnsafeIndexPointer </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given functional with an unsafe pointer to the raw index storage. </p>
<p>Indices are stored contiguously in memory: [i_0, i_1, ...].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Function that accepts a <code>Index const *</code> pointer as the only argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">noexcept(conditional)</td><td>iff <code>f(Index const *)</code> is noexcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functional </dd></dl>

</div>
</div>
<a class="anchor" id="a8173d354feb4ca374319272687f1f427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::withUnsafeLabelPointer </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given functional with an unsafe pointer to the raw label storage. </p>
<p>Labels are stored contiguously in memory: [l_0, l_1, ...].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Function that accepts a <code>Label const *</code> pointer as the only argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">noexcept(conditional)</td><td>iff <code>f(Label const *)</code> is noexcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functional </dd></dl>

</div>
</div>
<a class="anchor" id="ad52c7c438cecf75588ca5abb81793288"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::withUnsafeVertexNormalPointer </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given functional with an unsafe pointer to the raw per vertex normal storage. </p>
<p>Vertex normals are stored contiguously in memory: [dx_0, dy_0, dz_0, dx_1, dy_1, dz_1, ...].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Function that accepts a <code>Scalar const *</code> pointer as the only argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">noexcept(conditional)</td><td>iff <code>f(Scalar const *)</code> is noexcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functional </dd></dl>

</div>
</div>
<a class="anchor" id="a1f08cb96ee61f455b4f4d317764a5235"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::withUnsafeVertexPointer </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the given functional with an unsafe pointer to the raw vertex storage. </p>
<p>Vertices are stored contiguously in memory: [x_0, y_0, z_0, x_1, y_1, z_1, ...].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Function that accepts a <code>Scalar const *</code> pointer as the only argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">noexcept(conditional)</td><td>iff <code>f(Scalar const *)</code> is noexcept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functional </dd></dl>

</div>
</div>
<a class="anchor" id="ac19e59dc75cd1c4453e941e33b6681bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::writeToFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>meshFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>labelFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes mesh to ASCII file using format auto detection. </p>
<p>Supported file formats are: obj, off, stl, wrl, ply, mesh, SIMesh. Labels are written rowwise to <code>labelFilename</code>. For encoding the labels in the color attribute use the overload <code>writeToFile(std::string const &amp;, LabelToColorMap&lt;double, Label&gt; const &amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshFilename</td><td>path to the file to write the mesh to </td></tr>
    <tr><td class="paramname">labelFilename</td><td>path to the file to write the labels to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the mesh or the labels could not be writted to the given file </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the file file format could not be recognized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does nothing on empty meshes </dd></dl>

</div>
</div>
<a class="anchor" id="aea52ab27d64c744316abc0f565de1abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCortidQCT_1_1Mesh.html">CortidQCT::Mesh</a>&lt; T &gt;::writeToFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>meshFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceCortidQCT.html#a04ddf5259cabc1e1238ae30285564dfc">LabelToColorMap</a>&lt; double, <a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>labelMap</em> = <code><a class="el" href="namespaceCortidQCT_1_1LabelToColorMaps.html#a2fa866efe763cce246044753efbce53b">LabelToColorMaps::defaultMap</a>&lt;double,&#160;<a class="el" href="classCortidQCT_1_1Mesh.html#ab29bc2956971579d646fc291c73a28a6">Label</a>&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes mesh to ASCII file using format auto detection and encode labels as colors. </p>
<p>Supported file formats are: off (coff), SIMesh. The labels are encoded in per-vertex colors using the given label to color map. For the 'SIMesh' format the labels are written directly into the mesh file, ignoring the color encoding. For storing the labels in a separate file use the overload <code>writeToFile(std::string const &amp;, std::string const &amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshFilename</td><td>path to the file to write the mesh to </td></tr>
    <tr><td class="paramname">labelMap</td><td>function that maps labels to RGB color values. Defaults to <code><a class="el" href="namespaceCortidQCT_1_1LabelToColorMaps.html#a2fa866efe763cce246044753efbce53b" title="Default label to color map. ">LabelToColorMaps::defaultMap()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the mesh could not be writted to the given file </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the file file format could not be recognized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does nothing on empty meshes </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/CortidQCT/src/<a class="el" href="BarycentricPoint_8h_source.html">BarycentricPoint.h</a></li>
<li>include/CortidQCT/src/<a class="el" href="Mesh_8h_source.html">Mesh.h</a></li>
<li>lib/Mesh.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
